'''
Script to handle the defense launch, based off the current ADT state.

It uses the same State and Tree classes used in TreeAlchemist,
and maps each agent to a list of states based on the ADT.
Realistically, it is a dictionary from {ADT_name (str) : state (list[int])

This manager gets the alerts raised from syslog

The folder Trees contains a set of text files that help recreate the tree and nodes very simply.
They are automatically generated by ADT-Generator

Tree:
[100017, 100018...] # The id of the nodes, no matter the order
States:
[100017]=Def1
[100018]=Def2
[100017,100018]=Def3


General idea:
An alert is raised on Wazuh, and delivered to rsyslog, specifically on the file tree_alchemized_alerts.log
as specified in rsyslog config.

A tool watches the log file, and gathers the informations about the file modifications.
Each line of the log contains an alert, and the only important sections are the rule ID, the Tree name, and the Agent that raised the alert.

This daemon updates the tree state (there is a dictionary containing Agent name, with value another dict mapping a Tree Name to a list, the list being the state)


Please note that this version is Linux-specific, as it uses system calls.
'''

import os
from flask import Flask, request, jsonify
import logging
import read_toml
import ADT_daemon_readable_txt_parser
import wazuh_adtmanagerd_utils

app = Flask(__name__)

this_script_dir = os.path.dirname(__file__)
log_file_path = os.path.join(this_script_dir, 'Logs', 'wazuh_adtmanagerd.log')
tree_name_to_structure_dict = ADT_daemon_readable_txt_parser.parse_all_daemon_readable_files(os.path.join(this_script_dir, 'Trees'))


logging.basicConfig(
            filename=log_file_path,
            filemode='a',  # Append mode
            format='%(asctime)s - %(message)s',
            level=logging.INFO # This captures INFO and higher
)


app.logger = logging.getLogger()
app.logger.info("===== wazuh_adtmanagerd started =====")



@app.route('/new-alert', methods=['POST'])
def process_new_alert():
    data = request.json
    alert = data.get('alert')
    app.logger.info(f"Processing new alert: [ {alert} ] ============")

    alert_infos = wazuh_adtmanagerd_utils.parse_alert_log_line(alert)
    # Update tree state
    should_I_run_defense = update_tree_state(alert_infos)
    # Raise defenses if a state is matched
    if should_I_run_defense:
        run_defense_if_present(alert_infos)

    # You could add additional processing of the line here if needed
    return jsonify({"status": "success", "message": "Alert received"}), 200


def update_tree_state(alert_infos) -> bool:
    '''
    Returns False if the state was already present (you should NOT run defenses)

    True if the state was NOT present (you MUST run defenses)
    '''
    global tree_name_to_structure_dict

    tree_name = alert_infos['tree_name']
    curr_tree_structure_dict = tree_name_to_structure_dict[tree_name]

    curr_alert_id = alert_infos['rule_id']

    if curr_alert_id in curr_tree_structure_dict['current_state']:
        app.logger.info(f"Alert with rule id {curr_alert_id} has already been triggered: doing nothing.")
        return False
    
    curr_id_to_list = list(curr_tree_structure_dict['current_state'])
    curr_id_to_list.append(curr_alert_id)
    curr_tree_structure_dict['current_state'] = tuple(curr_id_to_list) # It's as a tuple because the idea that mutating it is hard is very fitting.

    return True


def run_defense_if_present(alert_infos):
    pass


@app.route('/', methods=['GET'])
def show_dashboard():
    return 'Hello World!'        






def run_webserver(port : int):
    global app   
    app.run(threaded=True, port=port, debug=False, use_reloader=False)

if __name__ == '__main__':
    run_webserver(read_toml.get_port())