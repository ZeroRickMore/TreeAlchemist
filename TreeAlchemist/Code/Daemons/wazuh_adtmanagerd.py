'''
Script to handle the defense launch, based off the current ADT state.

It uses the same State and Tree classes used in TreeAlchemist,
and maps each agent to a list of states based on the ADT.
Realistically, it is a dictionary from {ADT_name (str) : state (list[int])

This manager gets the alerts raised from syslog

The folder Trees contains a set of text files that help recreate the tree and nodes very simply.
They are automatically generated by ADT-Generator

Tree:
[100017, 100018...] # The id of the nodes, no matter the order
States:
[100017]=Def1
[100018]=Def2
[100017,100018]=Def3


General idea:
An alert is raised on Wazuh, and delivered to rsyslog, specifically on the file tree_alchemized_alerts.log
as specified in rsyslog config.

A tool watches the log file, and gathers the informations about the file modifications.
Each line of the log contains an alert, and the only important sections are the rule ID, the Tree name, and the Agent that raised the alert.

This daemon updates the tree state (there is a dictionary containing Agent name, with value another dict mapping a Tree Name to a list, the list being the state)


Please note that this version is Linux-specific, as it uses system calls.
'''

import os
from flask import Flask, request, jsonify
import logging
import read_toml
import ADT_daemon_readable_txt_parser
import wazuh_adtmanagerd_utils

app = Flask(__name__)

this_script_dir = os.path.dirname(__file__)
log_file_path = os.path.join(this_script_dir, 'Logs', 'wazuh_adtmanagerd.log')
tree_name_to_structure_dict = ADT_daemon_readable_txt_parser.parse_all_daemon_readable_files(os.path.join(this_script_dir, 'Trees'))


logging.basicConfig(
            filename=log_file_path,
            filemode='a',  # Append mode
            format='%(asctime)s - %(message)s',
            level=logging.INFO # This captures INFO and higher
)


app.logger = logging.getLogger()
app.logger.info("===== wazuh_adtmanagerd started =====")



@app.route('/new-alert', methods=['POST'])
def process_new_alert():
    data = request.json
    alert = data.get('alert')
    app.logger.info(f"Processing new alert: [ {alert} ] ============")

    alert_infos = wazuh_adtmanagerd_utils.parse_alert_log_line(alert)
    # Update tree state
    should_I_run_defense = update_tree_state(alert_infos)
    # Raise defenses if a state is matched
    if should_I_run_defense:
        which_defenses_ran_and_wazuh_api_response = run_defense_if_present(alert_infos)

    if not should_I_run_defense:
        return jsonify({"status": "success", "message": f"Alert {alert_infos['rule_id']} was already raised, doing nothing."}), 200
    
    if not which_defenses_ran_and_wazuh_api_response:
        return jsonify({"status": "success", "message": f"Alert {alert_infos['rule_id']} was not mapped to any defense, doing nothing."}), 200
    
    return jsonify({"status": "success", "message": f"Alert {alert_infos['rule_id']} led to the execution of some defenses." , "defenses_recap" : which_defenses_ran_and_wazuh_api_response}), 200


def update_tree_state(alert_infos) -> bool:
    '''
    Returns False if the state was already present (you should NOT run defenses)

    True if the state was NOT present (you MUST run defenses)
    '''
    global tree_name_to_structure_dict

    tree_name = alert_infos['tree_name']
    curr_tree_structure_dict = tree_name_to_structure_dict[tree_name]

    curr_alert_id = alert_infos['rule_id']

    if curr_alert_id in curr_tree_structure_dict['current_state']:
        app.logger.info(f"Alert with rule id {curr_alert_id} has already been triggered. Doing nothing.")
        return False
    
    curr_state_to_list = list(curr_tree_structure_dict['current_state'])
    curr_state_to_list.append(curr_alert_id)
    curr_tree_structure_dict['current_state'] = tuple(curr_state_to_list) # It's as a tuple because the idea that mutating it is hard is very fitting.

    return True


def run_defense_if_present(alert_infos) -> dict[str, dict]:
    '''
    Returns a dict of the defenses that were executed mapped to the raw response of Wazuh API .
    '''
    global tree_name_to_structure_dict

    tree_name = alert_infos['tree_name']
    curr_tree_structure_dict = tree_name_to_structure_dict[tree_name]
    curr_state_to_set = set(curr_tree_structure_dict['current_state']) # To allow orderless comparison
    curr_tree_states_that_have_a_defense = curr_tree_structure_dict['states_to_defenses']

    for state in curr_tree_states_that_have_a_defense:
        if curr_state_to_set == set(state):
            app.logger.info(f'A defense has been matched for state [ {state} ] in ADT = [ {tree_name} ]. Trying to launch it.')
            return launch_defense_commands(defense_command=curr_tree_states_that_have_a_defense[state])

    app.logger.info(f'No defenses found for state [ {curr_state_to_set} ] in ADT = [ {tree_name} ]. Doing nothing.')

    return {}
        
    
def launch_defense_commands(defense_command : str) -> dict[str, dict]:
    # Insert the logic to manage the PUT inside of WazuhServer API.
    '''
    Executes the defense commands, and returns a dictionary with defense -> raw response of Wazuh API .
    '''

    pass

    


@app.route('/', methods=['GET'])
def show_dashboard():
    return 'Hello World!'        






def run_webserver(port : int):
    global app   
    app.run(threaded=True, port=port, debug=False, use_reloader=False)

if __name__ == '__main__':
    run_webserver(read_toml.get_port())